package Chainsaw.project.ChipVerify

import Chainsaw.DataUtil
import Chainsaw.edaFlow.PythonHeaderGenerator
import Chainsaw.edaFlow.boards.alinx._
import Chainsaw.xillybus._
import spinal.core._
import spinal.lib._
import spinal.lib.bus.regif.{AccessType, HtmlGenerator}

import scala.language.postfixOps

/** Top module for ChipVerify project
  */
case class ChipVerify() extends AXKU041 {

  // CXP host blackbox
  val cxpHost = CxpHostWrapper()
  // CXP host <-> board connection
  cxpHost.UART <> UART
  led_test(1)  := False
  led_test(0)  := cxpHost.power_good

  // temp name for CXP <-> FMC-HPC card(part of FMC3)
  val fmc_ref_clk_n, fmc_ref_clk_p = in Bool ()
  val fmc_rx_n, fmc_rx_p           = in Bits (4 bits)
  val fmc_tx                       = out Bits (4 bits)
  val pocxp_en_tri_o               = out Bits (4 bits)

  cxpHost.fmc_ref_clk_n := fmc_ref_clk_n
  cxpHost.fmc_ref_clk_p := fmc_ref_clk_p
  cxpHost.fmc_rx_n      := fmc_rx_n
  cxpHost.fmc_rx_p      := fmc_rx_p

  fmc_tx         := cxpHost.fmc_tx
  pocxp_en_tri_o := cxpHost.pocxp_en_tri_o

  val dmaClockDomainConfig = ClockDomainConfig(clockEdge = RISING, resetKind = BOOT)
  val dmaClockDomain = ClockDomain(cxpHost.dma_clk, config = dmaClockDomainConfig, frequency = FixedFrequency(250 MHz))

  // enable/set direction for inout signals
  useFmc1(asMaster = true)

  // module connection
  // AN9767 -> FL1010 -> FMC2
  val an9767 = AN9767()
  FL1010(
    an9767.alinx40PinOut,
    an9767.alinx40PinOut
  ) <> FMC1_LPC // copy an9767 output to both 40pin connectors on FL1010

  // PCIe module using Xillybus

  // for block design, RTL module cannot contains IP
  val xillybus = XillybusWrapper.defaultWrapper(pinCount = 8, this.device)
  xillybus.pcieXilinx <> pcie

  // stream loopback for PCIe test
  val upload_8   = xillybus.getStreamToHost("read_8")
  val download_8 = xillybus.getStreamFromHost("write_8")
  download_8.queue(32, xillybus.xillyDomain, xillybus.xillyDomain) >> upload_8

  val upload_32   = xillybus.getStreamToHost("read_32")
  val download_32 = xillybus.getStreamFromHost("write_32")

  // creating system controller
  val ctrlDomain =
    new ClockingArea(xillybus.xillyDomain) { // register file should be instantiated in the same clock domain as xillybus
      val memBusIf = XillybusBusIf(xillybus.memBus)
      // creating system controller using xillybus mem device
      val trigger = memBusIf
        .newReg("trigger")
        .field(UInt(1 bits), AccessType.RW, 0, "trigger flag, generate pulse when this flag change")
      val pulseWidthForSample = memBusIf
        .newReg("pulseWidthForSample")
        .field(UInt(8 bits), AccessType.RW, 0, "pulsewidth control word(PCW), pulsewidth = PCW * 0.5us")
      val voltageForSample = memBusIf
        .newReg("voltageForSample")
        .field(
          UInt(8 bits),
          AccessType.RW,
          0,
          "voltage control word(VCW), voltage = VCW * 64 * (8.0V / 16383) - 4.0V"
        )
      val delayForCamera = memBusIf
        .newReg("delay")
        .field(UInt(8 bits), AccessType.RW, 0, "channel1 -> channel2 delay control word(DCW), delay = DCW * 0.5us")
      val pulseWidthForCamera = memBusIf
        .newReg("pulseWidthForCamera")
        .field(UInt(8 bits), AccessType.RW, 0, "pulse width in cycle")
      val voltageForCamera = memBusIf
        .newReg("voltageForCamera")
        .field(
          UInt(8 bits),
          AccessType.RW,
          0,
          "voltage control word(VCW), voltage = VCW * 64 * (8.0V / 16383) - 4.0V"
        )
      val periodForCamera = memBusIf
        .newReg("periodForCamera")
        .field(UInt(8 bits), AccessType.RW, 0, "period = CW * 0.5us")

      memBusIf.accept(PythonHeaderGenerator("regIf", "VerifyChip", "u32"))
      memBusIf.accept(HtmlGenerator("regIf", "VerifyChip"))

      // TODO: mark_debug conflict with async_reg
      // TODO: mark_debug on non-reg signal lead to unknown clock domain(which you need to specify manually)
      pulseWidthForSample.addAttribute("mark_debug", "true").setName("pulseWidth")
      delayForCamera.addAttribute("mark_debug", "true").setName("delay")
      voltageForSample.addAttribute("mark_debug", "true").setName("voltage")
    }

  dmaClockDomain on {
    def getControlWordCC[T <: Data](controlWord: T) = {
      controlWord.addTag(crossClockDomain)
      controlWord.d(3)
    }
    val pulseGen = PulseGen(dmaClockDomain.frequency)
    // a trigger can be generated by host program through PCIe, or by pressing user key
    val trigger = getControlWordCC(ctrlDomain.trigger).asBool.rise(False) || user_key.d(3).rise(False)
    trigger.addAttribute("mark_debug", "true")
    pulseGen.trigger     := trigger
    pulseGen.voltage0    := getControlWordCC(ctrlDomain.voltageForSample)
    pulseGen.voltage1    := getControlWordCC(ctrlDomain.voltageForCamera)
    pulseGen.pulseWidth0 := getControlWordCC(ctrlDomain.pulseWidthForSample)
    pulseGen.pulseWidth1 := getControlWordCC(ctrlDomain.pulseWidthForCamera)
    pulseGen.delay       := getControlWordCC(ctrlDomain.delayForCamera)
    pulseGen.period      := getControlWordCC(ctrlDomain.periodForCamera)
    Seq(an9767.channel1Clk, an9767.channel2Clk, an9767.channel1Wrt, an9767.channel2Wrt).foreach(
      _ := pulseGen.daClk
    ) // clk
    an9767.channel1 := pulseGen.channel1
    an9767.channel2 := pulseGen.channel2

    // frame processing
    val imageRx = ImageRx()
    cxpHost.dmaOut                                                     <> imageRx.dmaIn
    imageRx.streamOut.queue(128, dmaClockDomain, xillybus.xillyDomain) >> upload_32 // upload image data to host
    download_32.freeRun()
  }

}

object ChipVerify {
  def main(args: Array[String]): Unit = {
    SpinalVerilog(ChipVerify())
  }
}
