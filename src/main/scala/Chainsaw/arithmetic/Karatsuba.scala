package Chainsaw.arithmetic

import Chainsaw._
import Chainsaw.dag._
import Chainsaw.xilinx.VivadoUtilRequirement
import org.jgrapht._

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer
import scala.collection.JavaConverters._
import scala.language.postfixOps

/** hardware implementation of in-depth optimized Karatsuba Algorithm
 * @param width with of the Karatsuba multiplier
 * @param constant when one of the multiplicands is a constant
 */
case class Karatsuba(width: Int, constant: Option[BigInt] = None) extends Dag {

  override def name = s"karatsuba_$width"

  override def impl(dataIn: Seq[Any]) = Seq(dataIn.asInstanceOf[Seq[BigInt]].product)

  val baseWidth = 34
  val splitLimit = 96

  def getValidWidths(width: Int) = {
    val total = width.divideAndCeil(splitLimit)
    Seq.fill(total - 1)(splitLimit) :+ (width - (total - 1) * splitLimit)
  }

  var compensation = BigInt(0)

  /** --------
   * primitives used in Karatusba
   * -------- */
  implicit class karatsubaUtil(port: DagPort) {
    def split2 = {
      val s = Split(port.width, (port.width + 1) / 2).asVertex
      s := port
      (s.out(0), s.out(1))
    }

    def +^(that: DagPort) = {
      val add = Cpa(BinaryAdder, getValidWidths(that.width max port.width), S2S, withCarry = true).asVertex
      add := (port, that)
      add.out(0)
    }

    def +(that: DagPort) = {
      val add = Cpa(BinaryAdder, getValidWidths(that.width max port.width), S2S, withCarry = false).asVertex
      add := (port, that)
      add.out(0)
    }

    def -(that: DagPort) = {
      val add = Cpa(BinarySubtractor, getValidWidths(that.width max port.width), S2S, withCarry = false).asVertex
      add := (port, that)
      add.out(0)
    }

    def *(that: DagPort) = {
      require(port.width <= baseWidth && that.width <= baseWidth)
      val mult = Multiplier(Seq(port.width, that.width)).asVertex
      mult := (port, that)
      mult.out(0)
    }

    def karaWith(that: DagPort) = {
      val (aHigh, aLow) = port.split2
      val (bHigh, bLow) = that.split2
      val kara = KaraBase(aLow.width, bLow.width, Kara).asVertex
      kara := (aHigh, aLow, bHigh, bLow)
      kara.outPorts
    }

    def <<(shift: Int) = {
      val shiftLeft = ShiftLeft(shift, port.width).asVertex
      shiftLeft := port
      shiftLeft.out(0)
    }

    def resize(widthOut: Int) = {
      val re = Resize(port.width, widthOut).asVertex
      re := port
      re.out(0)
    }
  }

  def merge(operands: Seq[DagPort], infos: Seq[ArithInfo]) = {
    val treeGen = BitHeapCompressor(infos)
    compensation = treeGen.compensation
    logger.info(s"bits into compressor tree: ${infos.map(_.width).sum}")
    logger.info(s"latency of compressor tree: ${treeGen.latency}")
    val merge = treeGen.asVertex
    merge := (operands: _*)
    merge.outPorts
  }

  /** --------
   * full-DSP solution
   * -------- */
  // TODO: fine-tuned pipeline for pre addition
  val factors = Seq(2, 2, 2, 2, 2, 2) // decompositions generated by karasearch
  val segmentCount = factors.scan(1)(_ * _).reverse.takeWhile(count => width.divideAndCeil(count) <= splitLimit).last
  logger.info(s"segmentCount = $segmentCount, segmentWidth = ${width.divideAndCeil(segmentCount)}")

  /** --------
   * solution tradeoff
   * -------- */

  /** --------
   * graph construction
   * -------- */
  // TODO: more karatsuba construction method
  val Seq(a, b) = Seq.fill(2)(InputVertex(UIntInfo(width)))
  val o = OutputVertex(UIntInfo(width * 2))

  val products = ArrayBuffer[Port]()

  def buildRecursively(a: Port, b: Port): Port = {

    val splitWidth = (a.width + 1) / 2
    if (a.width <= baseWidth && b.width <= baseWidth) { // last layer, which is special

      val Seq(high, cross, low) = a karaWith b
      // FIXME: should directly port products from KaraBase to CompressorTree(no sync after multipliers)
      //      products ++= Seq(high, cross, low)
      val ret = (high << (splitWidth * 2)) + (cross << splitWidth) + low
      products += ret
      ret
    }
    else {
      val (aH, aL) = a.split2
      val (bH, bL) = b.split2
      val aMerge = aH +^ aL
      val bMerge = bH +^ bL

      val high = buildRecursively(aH, bH)
      val low = buildRecursively(aL, bL)
      val all = buildRecursively(aMerge, bMerge)

      val cross = all - high - low
      val ret = (high << (splitWidth * 2)) + (cross << splitWidth) + low
      ret.resize(a.width * 2)
    }
  }

  o := buildRecursively(a, b)
  this.autoPipeline()
  exportPng(s"kara${width}_before_rewriting")

  /** --------
   * partial retiming
   * -------- */
  //  val targets = Some(products.map(_.target))
  //  AutoPipeline(this, targets = targets)

  /** --------
   * post-addition rewriting
   * -------- */
  val pathFinder = new alg.shortestpath.AllDirectedPaths(this) // path finder from JGraphT
  val operandsAndInfos = ArrayBuffer[(Port, ArithInfo)]() // operands and their infos tobe added
  val redundantVertices = mutable.Set[DagVertex]() // vertices tobe removed

  val retimingBase = products.map(_.target).map(retimingInfo).min
  logger.info(
    s"\n----rewriting paths from products to out----" +
      s"\n\tnumber of products: ${products.length}"
  )
  products.foreach { product =>
    // TODO: will maxPathLength be a trouble maker? may be when width is extremely large
    val allPaths = pathFinder.getAllPaths(product.vertex, o.vertex, false, 100)
    allPaths.asScala.foreach { path =>
      var operandInfo = ArithInfo(product.width, 0, isPositive = true, retimingInfo(product.target) - retimingBase)
      path.getEdgeList.asScala.init.foreach { e =>
        redundantVertices += e.target
        e.target.gen match {
          case cpa: Cpa => if (cpa.adderType == BinarySubtractor && e.inOrder == 1) operandInfo = -operandInfo // else, keep
          case shiftLeft: ShiftLeft => operandInfo = operandInfo << shiftLeft.shift
          case resize: Resize => // do nothing
        }
      }
      operandsAndInfos += Tuple2(product, operandInfo)
    }
  }

  redundantVertices.foreach(removeVertex)

  logger.info(s"bits before inflation: ${products.map(_.width).sum}")
  val sortedOperands = operandsAndInfos.sortBy(_._2.time)

  val carrySaves = merge(sortedOperands.map(_._1), sortedOperands.map(_._2))
  val ret = carrySaves(0) +^ carrySaves(1)
  if (redundantVertices.nonEmpty) o := ret.resize(width * 2)

  /** --------
   * full retiming
   * -------- */
  autoPipeline()
  println(s"products: ${products.map(product => retimingInfo(product.vertex))}")
  graphDone()

  override def implNaiveH = Some(new ChainsawModule(this) {
    if (constant.nonEmpty) uintDataOut.head := (uintDataIn.head * constant.get).d(latency)
    else uintDataOut.head := uintDataIn.reduce(_ * _).d(latency)
  })
}

import spinal.core._

case class Multiplier(widths: Seq[Int]) extends ChainsawGenerator {

  require(widths.forall(_ <= 34) && widths.forall(_ > 17))

  override def name = s"mult_${widths.mkString("_")}"

  override def impl(dataIn: Seq[Any]) = {
    val Seq(a, b) = dataIn.asInstanceOf[Seq[BigInt]]
    require(a.bitLength <= widths.head, b.bitLength <= widths.last)
    Seq(a * b)
  }

  override var inputTypes = widths.map(UIntInfo(_))
  override var outputTypes = Seq(UIntInfo(widths.sum))

  override var inputFormat = inputNoControl
  override var outputFormat = outputNoControl
  override var latency = 6

  utilEstimation = VivadoUtilRequirement(dsp = 3)
  fmaxEstimation = 600 MHz

  override def implH: ChainsawModule = new ChainsawModule(this) {

    val karaCore = KaraBase(17, 17, Kara).implH

    val Seq(a, b) = dataIn
    val (aHigh, aLow) = a.splitAt(17)
    val (bHigh, bLow) = b.splitAt(17)

    karaCore.dataIn := Seq(aHigh, aLow, bHigh, bLow).map(_.resized)
    val Seq(high, cross, low) = karaCore.dataOut

    uintDataOut.head := ((high.asUInt.d(3) << 34) + (cross.asUInt << 17) + low.asUInt.d(3)).resize(widths.sum).d()
  }

  override def implNaiveH: Some[ChainsawModule] = Some(new ChainsawModule(this) {
    uintDataOut.head := uintDataIn.reduce(_ * _).d(latency)
  })

}

import scala.language.postfixOps