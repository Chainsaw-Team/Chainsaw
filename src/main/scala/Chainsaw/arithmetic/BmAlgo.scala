package Chainsaw.arithmetic

import Chainsaw._
import Chainsaw.xilinx.VivadoUtilEstimation

import scala.util.Random

/** long multiplication implemented by divide-and-conquer
 */
class BmAlgo(val bmSolution: BmSolution)
  extends HardAlgo with MultAttribute {

  // more accurate concept for clbCost

  // TODO: latency estimation
  // TODO: apply cmults by DSP limit

  override def constant = bmSolution.constant

  override def widthX = bmSolution.widthFull

  override def widthY = if (isConstantMult) constant.get.bitLength else bmSolution.widthFull

  override def multiplierType = bmSolution.multiplierType

  override def widthOut =
    if (multiplierType == MsbMultiplier || multiplierType == LsbMultiplier) bmSolution.widthFull
    else bmSolution.widthOut


  /** --------
   * cost statistics
   * -------- */
  var multCost = 0
  var fixCost = 0
  var splitCost = 0
  var mergeCost = 0
  var cmultCost = 0

  val weightMax =
    if (bmSolution.multiplierType == LsbMultiplier) bmSolution.widthFull
    else bmSolution.widthFull * 2

  val dspLatency = 2
  val andLatency = 1

  /** --------
   * operations in BmAlgo
   * -------- */
  def splitN(x: WeightedValue, n: Int): Seq[WeightedValue] = {
    val paddedWidth = x.arithInfo.width.nextMultipleOf(n)
    val values = x.value.toBitValue(paddedWidth).splitN(n)
    values.zip(x.arithInfo.splitN(n))
      .map { case (value, arithInfo) => WeightedValue(value, arithInfo) }
  }

  def splitMSB(x: WeightedValue) = {
    val (msb, main) = x.value.toBitValue(x.arithInfo.width).splitAt(x.arithInfo.width - 1)
    val (msbArithInfo, mainArithInfo) = x.arithInfo.splitMsb
    (WeightedValue(msb, msbArithInfo), WeightedValue(main, mainArithInfo))
  }

  def add(v0: WeightedValue, v1: WeightedValue, constant: Boolean = false) = {
    require(v0.arithInfo.width == v1.arithInfo.width, s"v0: ${v0.arithInfo}, v1: ${v1.arithInfo}")
    if (!constant) splitCost += v0.arithInfo.width
    WeightedValue(value = v0.value + v1.value, arithInfo = v0.arithInfo + v1.arithInfo)
  }

  def mult(v0: WeightedValue, v1: WeightedValue) = {
    require(v0.arithInfo.isPositive == v1.arithInfo.isPositive)
    require(v0.arithInfo.time == v1.arithInfo.time)

    val constantWeight = if (isConstantMult) Csd(v1.value).weight else v1.arithInfo.width
    val useCMult = isConstantMult && constantWeight < bmSolution.threshold
    if (useCMult) {
      cmultCost += bmSolution.dspSize._1 * (constantWeight - 1) // TODO: more accurate estimation
    } else {
      multCost += bmSolution.baseMultiplier.dspCost
      fixCost += bmSolution.baseMultiplier.clbCost
    }

    WeightedValue(value = v0.value * v1.value, arithInfo = v0.arithInfo * v1.arithInfo)
  }

  def and(v0: WeightedValue, v1: WeightedValue) = {
    WeightedValue(value = v0.value * v1.value, arithInfo = v0.arithInfo & v1.arithInfo)
  }

  def merge(weightedValues: Seq[WeightedValue], widthOut: Int): WeightedValue = {
    val base = weightedValues.map(_.arithInfo.weight).min
    mergeCost += (weightedValues.map(_.arithInfo.width).sum - widthOut)
    val value = weightedValues.map(_.eval).sum >> base
    WeightedValue(value = value,
      arithInfo = weightedValues.head.arithInfo.mergeWith(weightedValues.tail.map(_.arithInfo), widthOut))
  }

  /** --------
   * algorithm
   * -------- */
  def doRectangular(x: WeightedValue, y: WeightedValue, bmSolution: BmSolution): WeightedValue = {

    if (bmSolution.isEmpty) {
      if (x.arithInfo.weight + y.arithInfo.weight < weightMax) mult(x, y) else WeightedValue(0, ArithInfo(0, x.arithInfo.weight + y.arithInfo.weight))
    }
    else {

      val current = bmSolution.topDecomposition
      val currentType = current.multiplierType
      val currentWidthOut = current.widthOut
      import current._


      val aWords = splitN(x, aSplit) // width = baseHeight
      val bWords = splitN(y, bSplit) // width = baseWidth

      def doNSplit(aWords: Seq[WeightedValue], bWords: Seq[WeightedValue]): Seq[WeightedValue] = {

        currentType match {
          case FullMultiplier =>
            if (isKara) {
              val diagonals: Seq[WeightedValue] = (0 until split).map { i =>
                doRectangular(aWords(i), bWords(i), bmSolution.subSolution(bmSolution.multiplierType))
              }

              val prods: Seq[WeightedValue] = Seq.tabulate(split, split) { (i, j) =>
                if (i > j) { // upper triangular, generated by karatsuba method
                  // pre-addition
                  val weight = aWords(i).arithInfo.weight + bWords(j).arithInfo.weight
                  require(aWords(i).arithInfo.weight + bWords(j).arithInfo.weight == aWords(j).arithInfo.weight + bWords(i).arithInfo.weight)
                  val combinedA = add(aWords(i), aWords(j))
                  val combinedB = add(bWords(i), bWords(j), isConstantMult)
                  val (aMsb, aMain) = splitMSB(combinedA)
                  val (bMsb, bMain) = splitMSB(combinedB)
                  // sub-multiplication
                  val full = doRectangular(aMain, bMain, bmSolution.subSolution(FullMultiplier)).withWeight(weight)
                  val high = -diagonals(i).withWeight(weight)
                  val low = -diagonals(j).withWeight(weight)
                  // full - high - low
                  val mainSegments = Seq(full, high, low)
                  // side-multiplications
                  val sideA = and(bMain, aMsb).withWeight(weight + baseHeight)
                  val sideB = and(aMain, bMsb).withWeight(weight + baseWidth)
                  val ab = and(aMsb, bMsb).withWeight(weight + baseWidth + baseHeight)
                  val sideSegments = Seq(sideA, sideB, ab)
                  Some(mainSegments ++ sideSegments)
                } else None
              }.flatten.flatten.flatten
              diagonals ++ prods
            } else {
              Seq.tabulate(split, split) { (i, j) =>
                doRectangular(aWords(i), bWords(j), bmSolution.subSolution(bmSolution.multiplierType))
              }.flatten
            }

          case SquareMultiplier =>
            Seq.tabulate(split, split) { (i, j) =>
              if (i >= j) { // upper triangular
                val multType = if (i == j) bmSolution.multiplierType else FullMultiplier
                val prod = doRectangular(aWords(i), bWords(j), bmSolution.subSolution(multType))
                val ret = if (i != j) prod << 1 else prod
                Some(ret)
              } else None
            }.flatten.flatten

          case MsbMultiplier =>
            Seq.tabulate(split, split) { (i, j) =>
              if (i + j >= split - 1) {
                val multType = if (i + j == split - 1) bmSolution.multiplierType else FullMultiplier
                val ret = doRectangular(aWords(i), bWords(j), bmSolution.subSolution(multType))
                Some(ret)
              }
              else None
            }.flatten.flatten

          case LsbMultiplier =>
            Seq.tabulate(split, split) { (i, j) =>
              if (i + j <= split - 1) {
                val multType = if (i + j == split - 1) bmSolution.multiplierType else FullMultiplier
                val ret = doRectangular(aWords(i), bWords(j), bmSolution.subSolution(multType))
                Some(ret)
              }
              else None
            }.flatten.flatten
        }
      }

      val segments = Seq.tabulate(factorB, factorA) { (i, j) => // for rectangular
        // distribute words to N-split sub modules
        val as = aWords.zipWithIndex.filter(_._2 % factorB == i).map(_._1)
        val bs = bWords.zipWithIndex.filter(_._2 % factorA == j).map(_._1)
        doNSplit(as, bs)
      }.flatten.flatten

      val validSegments = segments.filter(_.arithInfo.weight < weightMax)
      assert(validSegments.forall(_.arithInfo.width != 0))
      val ret = merge(validSegments, currentWidthOut)
      ret
    }
  }

  /** --------
   * entrance to algorithm
   * -------- */
  def impl(x: BigInt, y: BigInt, verbose: Boolean = false): BigInt = {

    def adjustForMultType(value: BigInt) = {
      bmSolution.multiplierType match {
        case MsbMultiplier => value >> bmSolution.widthFull
        case LsbMultiplier => value.mod(Pow2(bmSolution.widthFull))
        case _ => value
      }
    }

    val yInUse = if (isConstantMult) bmSolution.constant.get else if (bmSolution.multiplierType == SquareMultiplier) x else y
    val tempGolden = x * yInUse
    val tempRet = doRectangular(
      WeightedValue(x, ArithInfo(bmSolution.widthFull, 0)),
      WeightedValue(yInUse, ArithInfo(bmSolution.widthFull, 0)),
      bmSolution).eval
    val golden = adjustForMultType(tempGolden)
    val ret = adjustForMultType(tempRet)

    if (verbose) {
      val multName = s"${bmSolution.widthFull}-bit ${if (isConstantMult) "constant" else "variable"} ${className(bmSolution.multiplierType)} threshold = ${bmSolution.threshold}"
      logger.info(
        s"\n----$multName----" +
          s"\n\tdspCost = $multCost" +
          s"\n\tclbCost = ${splitCost + mergeCost + cmultCost} = $splitCost(split) + $mergeCost(merge) + $cmultCost(cmult)"
      )
    }

    if (bmSolution.multiplierType != MsbMultiplier) assert(ret == golden, s"x $x, y $y, yours $ret, golden $golden")
    else {
      val error = ret - golden
      assert(error <= 0 && error >= -(bmSolution.widthFull / 2), s"error = $error")
      if (verbose) logger.info(s"error introduced by MSB multiplier: $error, ${ret.bitLength}, ${golden.bitLength}")
    }
    ret
  }

  def implConstantMult(x: BigInt, verbose: Boolean = false): BigInt = impl(x, null, verbose)

  def selfTest(): Unit = {
    def getMultiplicand = BigInt(bmSolution.widthFull, Random)

    val data = if (bmSolution.multiplierType == SquareMultiplier) Seq.fill(1000)(getMultiplicand).map(x => (x, x))
    else Seq.fill(1000)(getMultiplicand, getMultiplicand)
    data.foreach { case (x, y) => impl(x, y) }
    logger.info("bm algo test passed")
  }

  /** --------
   * determine cost while initializing
   * -------- */
  impl(BigInt(bmSolution.widthFull, Random), BigInt(bmSolution.widthFull, Random))
  val eff = 1.0 // TODO: vary for different sizes

  override def clbCost = (splitCost + fixCost + (mergeCost + cmultCost) / eff).toInt

  override def dspCost = multCost

  override def vivadoUtilEstimation =
    VivadoUtilEstimation(dsp = multCost, lut = clbCost, ff = clbCost * 2, bram36 = 0, uram288 = 0)
}

object BmAlgo {
  def apply(bmSolution: BmSolution): BmAlgo = new BmAlgo(bmSolution)
}