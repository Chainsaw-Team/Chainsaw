package Chainsaw

import Chainsaw.arithmetic.flopoco.FlopocoOperator
import Chainsaw.deprecated.ChainsawGenerator
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest._

import scala.util.Try
import org.apache.commons.io.FileUtils
import spinal.core.{EnumEtoEnumE2, SpinalConfig}

import java.util.Calendar

case class TestConfig(full: Boolean, naive: Boolean, synth: Boolean, impl: Boolean)

abstract class ChainsawFlatSpec extends AnyFlatSpec {

  def generatorConfigTable: Map[String, TestConfig] = Map[String, TestConfig]()

  def algoNames: Seq[String] = Seq[String]()

  def showTable(map: Map[String, TestConfig]) = {
    val header = s"| GeneratorName       | Full  | Naive | Synth | Impl  |"
    val separator = s"| ------------------- | ----- | ----- | ----- | ----- |"

    def getSymbol(boolean: Boolean) = s"   ${if (boolean) "●" else "○"}   "

    val body = map.map { case (name, config) =>
      val contents = Seq(config.full, config.naive, config.synth, config.impl).map(getSymbol).mkString("|")
      s"| ${name.padTo(20, " ").mkString("")}|$contents|"
    }.mkString("\n")
    s"$header\n$separator\n$body"
  }

  it should "show the test summary" in {
    logger.info("------------Chainsaw test summary------------" +
      s"\nalgorithms: \n\t${algoNames.mkString("\n\t")}" +
      s"\ngenerators: " +
      s"\n${showTable(generatorConfigTable)}")
  }

  def testGenerator(gen: => ChainsawGenerator, synth: Boolean = false, impl: Boolean = false): Unit = {

    behavior of gen.name

    it should "have a correct naive implementation" in {
      gen.setAsNaive()
      gen.doSelfTest()
    }

    it should "have a correct implementation" in {
      naiveSet.clear()
      gen.doSelfTest()
    }

    if (synth)
      it should "meet the util requirement after synth" in
        ChainsawSynthOld(gen, s"synth_${gen.name}", withRequirement = true)

    if (impl)
      it should "meet the util requirement after impl" in
        ChainsawImplOld(gen, s"impl_${gen.name}", withRequirement = true)
  }

  def testOperator(gen: => ChainsawBaseGenerator, testConfig: TestConfig): Unit = {

    import testConfig._

    behavior of gen.name

    if (full) {
      it should "work correctly" in {
        gen.doSelfTest()
      }
    }

    if (naive) {
      it should "has a correct naive implementation" in {
        gen.setAsNaive()
        assert(gen.useNaive)
        gen.doSelfTest()
        naiveSet.clear()
      }
    }

    if (synth && allowSynthAndImpl) { // when impl is set, synth is not necessary
      it should "meet the util & fmax requirement after synth" in
        ChainsawSynth(gen, withRequirement = true)
    }

    if (impl && allowSynthAndImpl) {
      it should "meet the util & fmax requirement after impl" in
        ChainsawImpl(gen, withRequirement = true)
    }
  }

  def testFlopocoOperator(gen: => FlopocoOperator, synth: Boolean, impl: Boolean): Unit = {

    behavior of gen.name

    it should "generate code by flopoco" in {
      val begin = Calendar.getInstance().get(Calendar.SECOND)
      gen.flopocoRun()
      val end = Calendar.getInstance().get(Calendar.SECOND)
      println(s"code generation takes ${end - begin} seconds")
    }

    it should "test the VHDL code generated by Flopoco" in {
      testFlopoco = true
      gen.doSelfTest()
    }

    it should "test the the RTL behavior model for test" in {
      testFlopoco = false
      gen.doSelfTest()
    }

    if (synth) {
      //      atSimTime = false
      it should "meet the util & fmax requirement after synth" in
        ChainsawSynth(gen, withRequirement = true)
    }

    if (impl) {
      //      atSimTime = false
      it should "meet the util & fmax requirement after impl" in
        ChainsawImpl(gen, withRequirement = true)
    }
  }
}