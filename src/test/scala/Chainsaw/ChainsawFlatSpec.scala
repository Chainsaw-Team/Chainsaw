package Chainsaw

import Chainsaw.arithmetic.flopoco.FlopocoOperator
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest._

import scala.util.{Random, Try}
import org.apache.commons.io.FileUtils
import spinal.core.{EnumEtoEnumE2, SpinalConfig}

import java.util.Calendar

case class TestConfig(
    full: Boolean,
    naive: Boolean,
    synth: Boolean,
    impl: Boolean,
    naiveList: Seq[String]                           = Seq[String](),
    utilRequirementStrategy: UtilRequirementStrategy = DefaultRequirement
)

abstract class ChainsawFlatSpec extends AnyFlatSpec {

  def generatorConfigTable: Map[String, TestConfig] = Map[String, TestConfig]()

  def algoNames: Seq[String] = Seq[String]()

  def showTable(map: Map[String, TestConfig]) = {
    val header    = s"| GeneratorName       | Full  | Naive | Synth | Impl  |"
    val separator = s"| ------------------- | ----- | ----- | ----- | ----- |"

    def getSymbol(boolean: Boolean) = s"   ${if (boolean) "●" else "○"}   "

    val body = map
      .map { case (name, config) =>
        val contents = Seq(config.full, config.naive, config.synth, config.impl)
          .map(getSymbol)
          .mkString("|")
        s"| ${name.padTo(20, " ").mkString("")}|$contents|"
      }
      .mkString("\n")
    s"$header\n$separator\n$body"
  }

  it should "show the test summary" in {
    logger.info(
      "------------Chainsaw test summary------------" +
        s"\nalgorithms: \n\t${algoNames.mkString("\n\t")}" +
        s"\ngenerators: " +
        s"\n${showTable(generatorConfigTable)}"
    )
  }

  def testOperator(
      gen: => ChainsawBaseGenerator,
      testConfig: TestConfig
  ): Unit = {

    import testConfig._

    behavior of gen.name

    if (full) {
      it should "work correctly" in {
        ChainsawSimBox(testConfig.naiveList) {
          gen.doSelfTest()
        }
      }
    }

    if (naive) {
      it should "has a correct naive implementation" in {
        gen.setAsNaive()
        assert(gen.useNaive)
        gen.doSelfTest()
        naiveSet.clear()
      }
    }

    if (synth && allowSynthAndImpl) { // when impl is set, synth is not necessary
      it should "meet the util & fmax requirement after synth" in
        ChainsawSynth(gen, testConfig.utilRequirementStrategy)
    }

    if (impl && allowSynthAndImpl) {
      it should "meet the util & fmax requirement after impl" in
        ChainsawImpl(gen, testConfig.utilRequirementStrategy)
    }
  }

  def testFlopocoOperator(
      gen: => FlopocoOperator,
      synth: Boolean,
      impl: Boolean
  ): Unit = {

    behavior of gen.name

    it should "generate code by flopoco" in {
      val begin = Calendar.getInstance().get(Calendar.SECOND)
      gen.flopocoRun()
      val end = Calendar.getInstance().get(Calendar.SECOND)
      println(s"code generation takes ${end - begin} seconds")
    }

    it should "test the VHDL code generated by Flopoco" in {
      testFlopoco = true
      gen.doSelfTest()
    }

    it should "test the the RTL behavior model for test" in {
      testFlopoco = false
      gen.doSelfTest()
    }

    if (synth) {
      //      atSimTime = false
      it should "meet the util & fmax requirement after synth" in
        ChainsawSynth(gen, PreciseRequirement)
    }

    if (impl) {
      //      atSimTime = false
      it should "meet the util & fmax requirement after impl" in
        ChainsawImpl(gen, PreciseRequirement)
    }
  }
}
